"""
Multi-customer proactive monitoring manager.

Manages isolated monitoring loops per customer with auto datasource discovery.
"""
from __future__ import annotations

import asyncio
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Set
from enum import Enum

from backend.intelligence.anomaly import (
    Anomaly,
    AnomalyDetector,
    TimeSeriesPoint,
    get_anomaly_detector
)
from backend.utils.logger import get_logger

logger = get_logger(__name__)


class DatasourceType(Enum):
    """Supported datasource types."""
    PROMETHEUS = "prometheus"
    LOKI = "loki"
    UNKNOWN = "unknown"


@dataclass
class Datasource:
    """Discovered datasource from a customer's Grafana."""
    uid: str
    name: str
    type: DatasourceType
    url: Optional[str] = None
    is_default: bool = False


@dataclass 
class MonitoringTarget:
    """Configuration for a metric to monitor."""
    name: str
    customer_name: str  # NEW: Customer this target belongs to
    query: str  # PromQL or LogQL query
    datasource_uid: str
    query_type: str  # "prometheus" or "loki"
    check_interval: int  # seconds
    detection_methods: List[str]
    severity_threshold: str  # Minimum severity to alert on
    enabled: bool = True
    last_check: Optional[datetime] = None
    last_error: Optional[str] = None


@dataclass
class ProactiveAlert:
    """Alert generated by proactive monitoring."""
    id: str
    timestamp: datetime
    customer_name: str  # NEW: Customer this alert belongs to
    target_name: str
    anomalies: List[Anomaly]
    investigation: Optional[str] = None
    severity: str = "medium"
    acknowledged: bool = False
    acknowledged_by: Optional[str] = None
    acknowledged_at: Optional[datetime] = None


@dataclass
class CustomerMonitoringState:
    """State for a single customer's monitoring."""
    customer_name: str
    targets: Dict[str, MonitoringTarget] = field(default_factory=dict)
    alerts: List[ProactiveAlert] = field(default_factory=list)
    datasources: Dict[str, Datasource] = field(default_factory=dict)
    running: bool = False
    last_datasource_discovery: Optional[datetime] = None
    task: Optional[asyncio.Task] = None
    mcp_client: Optional[Any] = None  # Will be set when customer is activated
    
    def get_default_datasource(self, ds_type: DatasourceType) -> Optional[Datasource]:
        """Get default datasource of a given type."""
        for ds in self.datasources.values():
            if ds.type == ds_type and ds.is_default:
                return ds
        # Fallback to first of type
        for ds in self.datasources.values():
            if ds.type == ds_type:
                return ds
        return None


@dataclass
class CustomerHealth:
    """Health summary for a customer (for NOC dashboard)."""
    customer_name: str
    is_monitoring: bool
    targets_count: int
    enabled_targets: int
    total_alerts: int
    critical_alerts: int
    warning_alerts: int
    last_check: Optional[datetime]
    status: str  # "healthy", "warning", "critical", "unknown"


class CustomerMonitoringManager:
    """
    Manages isolated monitoring loops for multiple customers.
    
    Each customer has their own:
    - Monitoring targets
    - Alerts
    - Discovered datasources
    - Background monitoring task
    """
    
    def __init__(self):
        self.customers: Dict[str, CustomerMonitoringState] = {}
        self.anomaly_detector = get_anomaly_detector()
        self.alert_callbacks: List[callable] = []
        self._alert_counter = 0
        
    def _generate_alert_id(self) -> str:
        """Generate unique alert ID."""
        self._alert_counter += 1
        return f"alert-{datetime.utcnow().strftime('%Y%m%d%H%M%S')}-{self._alert_counter}"
    
    def get_or_create_customer(self, customer_name: str) -> CustomerMonitoringState:
        """Get or create monitoring state for a customer."""
        if customer_name not in self.customers:
            self.customers[customer_name] = CustomerMonitoringState(customer_name=customer_name)
            logger.info(f"Created monitoring state for customer: {customer_name}")
        return self.customers[customer_name]
    
    def set_customer_mcp_client(self, customer_name: str, mcp_client: Any):
        """Set the MCP client for a customer (called when customer is activated)."""
        state = self.get_or_create_customer(customer_name)
        state.mcp_client = mcp_client
        logger.info(f"Set MCP client for customer: {customer_name}")
    
    # ==================== Datasource Discovery ====================
    
    async def discover_datasources(self, customer_name: str) -> List[Datasource]:
        """
        Discover available datasources from a customer's Grafana.
        
        Queries the Grafana MCP server to get all datasources and their types.
        """
        state = self.get_or_create_customer(customer_name)
        
        if not state.mcp_client:
            logger.warning(f"No MCP client for {customer_name}, cannot discover datasources")
            return []
        
        try:
            # Call list_datasources tool
            result = await state.mcp_client.invoke_tool("list_datasources", {})
            
            datasources = []
            if isinstance(result, list):
                for ds_data in result:
                    ds_type = DatasourceType.UNKNOWN
                    type_str = ds_data.get("type", "").lower()
                    if "prometheus" in type_str:
                        ds_type = DatasourceType.PROMETHEUS
                    elif "loki" in type_str:
                        ds_type = DatasourceType.LOKI
                    
                    ds = Datasource(
                        uid=ds_data.get("uid", ""),
                        name=ds_data.get("name", ""),
                        type=ds_type,
                        url=ds_data.get("url"),
                        is_default=ds_data.get("isDefault", False)
                    )
                    datasources.append(ds)
                    state.datasources[ds.uid] = ds
            
            state.last_datasource_discovery = datetime.utcnow()
            logger.info(f"Discovered {len(datasources)} datasources for {customer_name}")
            
            return datasources
            
        except Exception as e:
            logger.error(f"Failed to discover datasources for {customer_name}: {e}")
            return []
    
    def get_datasources(self, customer_name: str) -> List[Datasource]:
        """Get discovered datasources for a customer."""
        state = self.customers.get(customer_name)
        if not state:
            return []
        return list(state.datasources.values())
    
    # ==================== Target Management ====================
    
    def add_target(self, customer_name: str, target: MonitoringTarget):
        """Add a monitoring target for a customer."""
        state = self.get_or_create_customer(customer_name)
        target.customer_name = customer_name
        state.targets[target.name] = target
        logger.info(f"Added target '{target.name}' for customer: {customer_name}")
    
    def remove_target(self, customer_name: str, target_name: str):
        """Remove a monitoring target."""
        state = self.customers.get(customer_name)
        if state and target_name in state.targets:
            del state.targets[target_name]
            logger.info(f"Removed target '{target_name}' for customer: {customer_name}")
    
    def get_targets(self, customer_name: Optional[str] = None) -> List[MonitoringTarget]:
        """Get targets, optionally filtered by customer."""
        if customer_name:
            state = self.customers.get(customer_name)
            return list(state.targets.values()) if state else []
        
        # Return all targets across all customers
        all_targets = []
        for state in self.customers.values():
            all_targets.extend(state.targets.values())
        return all_targets
    
    def enable_target(self, customer_name: str, target_name: str):
        """Enable a monitoring target."""
        state = self.customers.get(customer_name)
        if state and target_name in state.targets:
            state.targets[target_name].enabled = True
    
    def disable_target(self, customer_name: str, target_name: str):
        """Disable a monitoring target."""
        state = self.customers.get(customer_name)
        if state and target_name in state.targets:
            state.targets[target_name].enabled = False
    
    # ==================== Alert Management ====================
    
    def get_alerts(
        self, 
        customer_name: Optional[str] = None,
        min_severity: str = "low",
        minutes: int = 60,
        include_acknowledged: bool = False
    ) -> List[ProactiveAlert]:
        """Get alerts, optionally filtered by customer and severity."""
        severity_levels = {"low": 0, "medium": 1, "high": 2, "critical": 3}
        min_level = severity_levels.get(min_severity, 0)
        cutoff = datetime.utcnow() - timedelta(minutes=minutes)
        
        def filter_alert(alert: ProactiveAlert) -> bool:
            if alert.timestamp < cutoff:
                return False
            if severity_levels.get(alert.severity, 0) < min_level:
                return False
            if not include_acknowledged and alert.acknowledged:
                return False
            return True
        
        if customer_name:
            state = self.customers.get(customer_name)
            if not state:
                return []
            return [a for a in state.alerts if filter_alert(a)]
        
        # Return all alerts across all customers
        all_alerts = []
        for state in self.customers.values():
            all_alerts.extend([a for a in state.alerts if filter_alert(a)])
        return sorted(all_alerts, key=lambda a: a.timestamp, reverse=True)
    
    def acknowledge_alert(self, customer_name: str, alert_id: str, user: str = "system"):
        """Acknowledge an alert."""
        state = self.customers.get(customer_name)
        if not state:
            return False
        
        for alert in state.alerts:
            if alert.id == alert_id:
                alert.acknowledged = True
                alert.acknowledged_by = user
                alert.acknowledged_at = datetime.utcnow()
                return True
        return False
    
    # ==================== Monitoring Loop ====================
    
    async def start_customer_monitoring(self, customer_name: str):
        """Start the monitoring loop for a specific customer."""
        state = self.get_or_create_customer(customer_name)
        
        if state.running:
            logger.warning(f"Monitoring already running for {customer_name}")
            return
        
        if not state.mcp_client:
            logger.error(f"Cannot start monitoring for {customer_name}: no MCP client")
            return
        
        # Discover datasources first
        await self.discover_datasources(customer_name)
        
        state.running = True
        state.task = asyncio.create_task(self._customer_monitoring_loop(customer_name))
        logger.info(f"Started monitoring for customer: {customer_name}")
    
    async def stop_customer_monitoring(self, customer_name: str):
        """Stop the monitoring loop for a specific customer."""
        state = self.customers.get(customer_name)
        if not state:
            return
        
        state.running = False
        if state.task:
            state.task.cancel()
            try:
                await state.task
            except asyncio.CancelledError:
                pass
        logger.info(f"Stopped monitoring for customer: {customer_name}")
    
    async def _customer_monitoring_loop(self, customer_name: str):
        """Main monitoring loop for a single customer."""
        state = self.customers.get(customer_name)
        if not state:
            return
        
        logger.info(f"Starting monitoring loop for {customer_name}")
        
        while state.running:
            try:
                for target in list(state.targets.values()):
                    if not target.enabled:
                        continue
                    
                    # Check if it's time
                    if target.last_check:
                        elapsed = (datetime.utcnow() - target.last_check).total_seconds()
                        if elapsed < target.check_interval:
                            continue
                    
                    await self._check_target(state, target)
                
                await asyncio.sleep(10)
                
            except Exception as e:
                logger.error(f"Error in monitoring loop for {customer_name}: {e}")
                await asyncio.sleep(30)
    
    async def _check_target(self, state: CustomerMonitoringState, target: MonitoringTarget):
        """Check a single target for anomalies."""
        try:
            data = await self._fetch_metric_data(state, target)
            
            if not data:
                target.last_check = datetime.utcnow()
                target.last_error = "No data returned"
                return
            
            time_series = self._parse_time_series(data, target.query_type)
            
            if len(time_series) < 3:
                target.last_check = datetime.utcnow()
                return
            
            anomalies = self.anomaly_detector.detect_anomalies(
                data=time_series,
                metric_name=target.name,
                methods=target.detection_methods
            )
            
            severity_levels = {"low": 0, "medium": 1, "high": 2, "critical": 3}
            threshold = severity_levels.get(target.severity_threshold, 1)
            
            significant = [
                a for a in anomalies
                if severity_levels.get(a.severity, 0) >= threshold
            ]
            
            if significant:
                await self._create_alert(state, target, significant)
            
            target.last_check = datetime.utcnow()
            target.last_error = None
            
        except Exception as e:
            logger.error(f"Error checking target {target.name}: {e}")
            target.last_check = datetime.utcnow()
            target.last_error = str(e)
    
    async def _fetch_metric_data(self, state: CustomerMonitoringState, target: MonitoringTarget) -> Any:
        """Fetch metric data using customer's MCP client."""
        if not state.mcp_client:
            return None
        
        try:
            if target.query_type == "prometheus":
                result = await state.mcp_client.invoke_tool(
                    "query_prometheus",
                    {
                        "datasourceUid": target.datasource_uid,
                        "expr": target.query,
                        "startTime": "now-1h",
                        "endTime": "now",
                        "stepSeconds": 60,
                        "queryType": "range"
                    }
                )
                return result
            elif target.query_type == "loki":
                result = await state.mcp_client.invoke_tool(
                    "query_loki_logs",
                    {
                        "datasourceUid": target.datasource_uid,
                        "query": target.query,
                        "startRfc3339": "now-1h",
                        "endRfc3339": "now"
                    }
                )
                return result
        except Exception as e:
            logger.error(f"Error fetching data for {target.name}: {e}")
            return None
    
    def _parse_time_series(self, data: Any, query_type: str) -> List[TimeSeriesPoint]:
        """Parse MCP response into time series points."""
        points = []
        
        try:
            if query_type == "prometheus":
                if isinstance(data, dict) and "data" in data:
                    result = data.get("data", {}).get("result", [])
                    if result and len(result) > 0:
                        values = result[0].get("values", [])
                        for ts, val in values:
                            points.append(TimeSeriesPoint(
                                timestamp=datetime.fromtimestamp(float(ts)),
                                value=float(val)
                            ))
            elif query_type == "loki":
                if isinstance(data, dict):
                    streams = data.get("data", {}).get("result", [])
                    for stream in streams:
                        for ts, _ in stream.get("values", []):
                            points.append(TimeSeriesPoint(
                                timestamp=datetime.fromtimestamp(float(ts) / 1e9),
                                value=1.0
                            ))
        except Exception as e:
            logger.error(f"Error parsing time series: {e}")
        
        return sorted(points, key=lambda p: p.timestamp)
    
    async def _create_alert(
        self, 
        state: CustomerMonitoringState, 
        target: MonitoringTarget, 
        anomalies: List[Anomaly]
    ):
        """Create an alert from detected anomalies."""
        max_severity = max(
            ({"low": 0, "medium": 1, "high": 2, "critical": 3}.get(a.severity, 0), a.severity)
            for a in anomalies
        )[1]
        
        alert = ProactiveAlert(
            id=self._generate_alert_id(),
            timestamp=datetime.utcnow(),
            customer_name=state.customer_name,
            target_name=target.name,
            anomalies=anomalies,
            severity=max_severity
        )
        
        state.alerts.append(alert)
        
        # Keep only last 1000 alerts per customer
        if len(state.alerts) > 1000:
            state.alerts = state.alerts[-1000:]
        
        logger.warning(
            f"Alert created for {state.customer_name}/{target.name}: "
            f"{len(anomalies)} anomalies, severity={max_severity}"
        )
        
        # Notify callbacks
        for callback in self.alert_callbacks:
            try:
                await callback(alert)
            except Exception as e:
                logger.error(f"Alert callback error: {e}")
    
    # ==================== NOC Dashboard ====================
    
    def get_all_customer_health(self) -> List[CustomerHealth]:
        """Get health summary for all customers (for NOC dashboard)."""
        health_list = []
        
        for name, state in self.customers.items():
            recent_alerts = [
                a for a in state.alerts
                if a.timestamp > datetime.utcnow() - timedelta(hours=1)
                and not a.acknowledged
            ]
            
            critical = len([a for a in recent_alerts if a.severity == "critical"])
            warning = len([a for a in recent_alerts if a.severity in ("high", "warning")])
            
            if critical > 0:
                status = "critical"
            elif warning > 0:
                status = "warning"
            elif state.running:
                status = "healthy"
            else:
                status = "unknown"
            
            # Find most recent check time
            last_check = None
            for target in state.targets.values():
                if target.last_check:
                    if not last_check or target.last_check > last_check:
                        last_check = target.last_check
            
            health_list.append(CustomerHealth(
                customer_name=name,
                is_monitoring=state.running,
                targets_count=len(state.targets),
                enabled_targets=sum(1 for t in state.targets.values() if t.enabled),
                total_alerts=len(state.alerts),
                critical_alerts=critical,
                warning_alerts=warning,
                last_check=last_check,
                status=status
            ))
        
        return sorted(health_list, key=lambda h: (
            {"critical": 0, "warning": 1, "healthy": 2, "unknown": 3}.get(h.status, 4),
            h.customer_name
        ))
    
    def get_monitoring_status(self, customer_name: Optional[str] = None) -> dict:
        """Get monitoring status, optionally for a specific customer."""
        if customer_name:
            state = self.customers.get(customer_name)
            if not state:
                return {
                    "running": False,
                    "targets_count": 0,
                    "enabled_targets": 0,
                    "total_alerts": 0,
                    "recent_alerts": 0,
                    "critical_alerts": 0,
                    "customer_name": customer_name
                }
            
            recent = [
                a for a in state.alerts
                if a.timestamp > datetime.utcnow() - timedelta(hours=1)
            ]
            
            return {
                "running": state.running,
                "targets_count": len(state.targets),
                "enabled_targets": sum(1 for t in state.targets.values() if t.enabled),
                "total_alerts": len(state.alerts),
                "recent_alerts": len(recent),
                "critical_alerts": len([a for a in recent if a.severity == "critical" and not a.acknowledged]),
                "customer_name": customer_name
            }
        
        # Aggregate across all customers
        total_targets = sum(len(s.targets) for s in self.customers.values())
        enabled = sum(sum(1 for t in s.targets.values() if t.enabled) for s in self.customers.values())
        all_alerts = sum(len(s.alerts) for s in self.customers.values())
        
        recent_alerts = []
        for state in self.customers.values():
            recent_alerts.extend([
                a for a in state.alerts
                if a.timestamp > datetime.utcnow() - timedelta(hours=1)
            ])
        
        running_count = sum(1 for s in self.customers.values() if s.running)
        
        return {
            "running": running_count > 0,
            "running_customers": running_count,
            "total_customers": len(self.customers),
            "targets_count": total_targets,
            "enabled_targets": enabled,
            "total_alerts": all_alerts,
            "recent_alerts": len(recent_alerts),
            "critical_alerts": len([a for a in recent_alerts if a.severity == "critical" and not a.acknowledged])
        }


# Global singleton
_customer_monitoring_manager: Optional[CustomerMonitoringManager] = None


def get_customer_monitoring_manager() -> CustomerMonitoringManager:
    """Get or create the global customer monitoring manager."""
    global _customer_monitoring_manager
    if _customer_monitoring_manager is None:
        _customer_monitoring_manager = CustomerMonitoringManager()
        logger.info("Initialized customer monitoring manager")
    return _customer_monitoring_manager


def create_default_targets_for_customer(customer_name: str, prometheus_uid: str = "prometheus") -> List[MonitoringTarget]:
    """Create default monitoring targets for a customer."""
    return [
        MonitoringTarget(
            name="error_rate",
            customer_name=customer_name,
            query='rate(http_requests_total{status=~"5.."}[5m])',
            datasource_uid=prometheus_uid,
            query_type="prometheus",
            check_interval=300,
            detection_methods=["zscore", "rate_change"],
            severity_threshold="medium"
        ),
        MonitoringTarget(
            name="cpu_usage",
            customer_name=customer_name,
            query='100 - (avg by (instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)',
            datasource_uid=prometheus_uid,
            query_type="prometheus",
            check_interval=180,
            detection_methods=["zscore", "iqr"],
            severity_threshold="high"
        ),
        MonitoringTarget(
            name="memory_usage",
            customer_name=customer_name,
            query='(node_memory_MemTotal_bytes - node_memory_MemAvailable_bytes) / node_memory_MemTotal_bytes * 100',
            datasource_uid=prometheus_uid,
            query_type="prometheus",
            check_interval=300,
            detection_methods=["zscore"],
            severity_threshold="high"
        ),
        MonitoringTarget(
            name="disk_usage",
            customer_name=customer_name,
            query='100 - ((node_filesystem_avail_bytes{mountpoint="/"} / node_filesystem_size_bytes{mountpoint="/"}) * 100)',
            datasource_uid=prometheus_uid,
            query_type="prometheus",
            check_interval=600,
            detection_methods=["zscore"],
            severity_threshold="high"
        )
    ]
